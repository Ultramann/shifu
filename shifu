#! /bin/sh
# Dependencies: sed

shifu_mode_cmds=0
shifu_mode_args=1
shifu_mode_help=2

shifu_cmd_name() {
  # 1: command name
  [ $# -ne 1 ] && { echo "Commands cannot contain spaces got: \"$@\""; exit 1; }
  [ $mode -ne $shifu_mode_args ] && cmd_name="$1"
}

shifu_cmd_help() {
  # @: help string
  [ $mode -ne $shifu_mode_args ] && cmd_help="$@"
}

shifu_cmd_long() {
  # @: long help string
  [ $mode -ne $shifu_mode_args ] && cmd_long="$@"
}

shifu_cmd_subs() {
  # @: subcommand function names
  [ $mode -ne $shifu_mode_args ] && cmd_subs="$@"
}

shifu_cmd_func() {
  # @: command function name
  [ $mode -ne $shifu_mode_args ] && cmd_func="$@"
}

shifu_arg() {
  case $mode in
    $shifu_mode_help) _shifu_arg_help "$@" ;;
    $shifu_mode_args) _shifu_parse_arg "$@" ;;
    *) return
  esac
}

shifu_run_cmd() {
  shifu_var_store mode parent arg arg_matched cmd cmd_name cmd_help cmd_long cmd_subs cmd_func
  mode=$shifu_mode_cmds
  parent="$1"; shift; "$parent"; shifu_cmds="$cmd_subs"
  while [ $# -ne 0 ]; do
    arg="$1"; shift
    arg_matched=''
    for cmd in $shifu_cmds; do
      _shifu_clear_cmd_vars
      "$cmd"
      [ "$arg" != "$cmd_name" ] && continue
      arg_matched=true
      [ -n "$cmd_func" ] && break
      parent="$cmd"
      shifu_cmds="$cmd_subs"
      break
    done
    [ "$arg_matched" = true -a -n "$cmd_func" ] && break
    [ "$arg_matched" = true -a -n "$cmd_subs" ] && continue
    echo "unknown command: $arg"
    shifu_help "$parent"
    exit 1
  done
  [ -z "$cmd_func" ] && { echo "$cmd_name" requires arguments; shifu_help "$cmd"; exit 1; }
  [ "$1" = "-h" -o "$1" = "--help" ] && shifu_help "$cmd" || "$cmd_func" "$@"
  shifu_var_restore mode parent arg arg_matched cmd cmd_name cmd_help cmd_long cmd_subs cmd_func
}

shifu_parse_args() {
  # 1: function, 2-: args to parse
  shifu_var_store mode parse_stage cmd case_stmt has_options
  mode=$shifu_mode_args
  parse_stage=0
  cmd="$1"; shift
  case_stmt="case \"\$1\" in -h|--help) shifu_help \"$cmd\"; exit 0 ;; "
  "$cmd"
  [ $parse_stage -eq 0 ] && case_stmt="$case_stmt *) "
  case_stmt="$case_stmt break ;; esac"
  while true; do
    eval "$case_stmt"
  done
  shifu_remaining_args=$(_shifu_save_remaining_args "$@")
  shifu_var_restore mode cmd parse_stage case_stmt has_options
}

shifu_help() {
  shifu_var_store mode help_stage help_usage help_arguments help_options help_string has_options
  mode=$shifu_mode_help
  _shifu_clear_cmd_vars
  help_stage=0 help_usage='' help_arguments='' help_options='' help_string=''
  "$1"
  help_options="$help_options\n  -h, --help\n    Show this help"
  [ -n "$help_usage" ] && help_usage="$cmd_name [OPTIONS]$help_usage"
  [ -n "$cmd_help" ] && _shifu_add_to_help_string "$cmd_help"
  [ -n "$cmd_long" ] && _shifu_add_to_help_string "$cmd_long"
  [ -n "$help_usage" ] && _shifu_add_to_help_string "Usage\n  $help_usage"
  [ -n "$help_arguments" ] && _shifu_add_to_help_string "Arguments$help_arguments"
  [ -n "$help_options" ] && _shifu_add_to_help_string "Options$help_options"
  [ -n "$help_string" ] && printf "$help_string\n"
  shifu_var_restore mode help_stage help_usage help_arguments help_options help_string has_options
}

shifu_var_store() {
  while [ $# -ne 0 ]; do
    [ -z "$1" ] && { shift; continue; }
    eval "[ -z \$shifu_${1}_shifu ] && shifu_${1}_shifu=\$$1 || \\
          { echo \"Cannot use variable 'shifu_${1}_shifu'\"; exit 1; }"
    shift
  done
}

shifu_var_restore() {
  while [ $# -ne 0 ]; do
    eval "$1=\$shifu_${1}_shifu; unset -v shifu_${1}_shifu"
    shift
  done
}

_shifu_clear_cmd_vars() {
    cmd_name='' cmd_help='' cmd_long='' cmd_subs='' cmd_func=''
}

_shifu_arg_help() {
  has_options=0
  [ $# -gt 1 -a "$1" != -- ] && { has_options=1; help_options="$help_options\n  $1"; shift; }
  while [ $# -gt 1 -a "$1" != -- ]; do
    help_options="  $help_options, $1"; shift
  done; shift
 # remaining
  if [ $# -eq 1 ]; then
    help_stage=2
    help_usage="$help_usage ..."
    help_arguments="$help_arguments\nRemaining\n\t$1"
  # positional
  elif [ $has_options -eq 0 ]; then
    if [ $help_stage -lt 1 ]; then
      help_stage=1
    elif [ $help_stage -gt 1 ]; then
      echo "No arguments after remaining are declared: $1"; exit 1;
    fi
    help_usage="$help_usage $1"
    help_arguments="$help_arguments\n  $1\n    $2"
  # option + argument without default
  elif [ $# -eq 2 ]; then
    [ $help_stage -gt 0 ] && { echo "No options after positional/remaining arguments: $1"; exit 1; }
    help_options="$help_options $1\n    $2"
  # option + argument with default
  elif [ $# -eq 3 ]; then
    [ $help_stage -gt 0 ] && { echo "No options after positional/remaining arguments: $1"; exit 1; }
    help_options="$help_options $1\n    $3. Default: $2."
  # option no argument default set
  elif [ $# -eq 4 ]; then
    [ $help_stage -gt 0 ] && { echo "No options after positional/remaining arguments: $1"; exit 1; }
    help_options="$help_options\n    $4 Set: $3, default: $2."
  fi
}

_shifu_parse_arg() {
  has_options=0
  [ $# -gt 1 -a "$1" != -- ] && { has_options=1; case_stmt="$case_stmt $1"; shift; }
  while [ $# -gt 1 -a "$1" != -- ]; do
    case_stmt="${case_stmt}|$1"; shift
  done; shift
  # remaining
  if [ $# -eq 1 ]; then
    parse_stage=2
  # positional
  elif [ $has_options -eq 0 ]; then
    if [ $parse_stage -lt 1 ]; then
      parse_stage=1
      case_stmt="$case_stmt -*|--*) echo 'Invalid option $1'; exit 1 ;; "
      case_stmt="$case_stmt *)"
    elif [ $parse_stage -gt 1 ]; then
      echo "No arguments after remaining are declared: $1"; exit 1;
    fi
    eval "$1=" > /dev/null 2>&1
    [ $? -ne 0 ] && { echo "Invalid variable name: $1"; exit 1; }
    case_stmt="$case_stmt [ \$# -eq 0 ] && { echo 'Missing positional argument $1'; exit 1; }; "
    case_stmt="$case_stmt $1=\$1; shift; "
  # option + argument without default
  elif [ $# -eq 2 ]; then
    [ $parse_stage -gt 0 ] && { echo "No options after positional/remaining arguments: $1"; exit 1; }
    eval "$1=" > /dev/null 2>&1
    [ $? -ne 0 ] && { echo "Invalid variable name: $1"; exit 1; }
    case_stmt="$case_stmt) $1=\$2; shift; shift ;; "
  # option + argument with default
  elif [ $# -eq 3 ]; then
    [ $parse_stage -gt 0 ] && { echo "No options after positional/remaining arguments: $1"; exit 1; }
    eval "$1=$2" > /dev/null 2>&1
    [ $? -ne 0 ] && { echo "Invalid variable name: $1"; exit 1; }
    case_stmt="$case_stmt) $1=\$2; shift; shift ;; "
  # option no argument default set
  elif [ $# -eq 4 ]; then
    [ $parse_stage -gt 0 ] && { echo "No options after positional/remaining arguments: $1"; exit 1; }
    eval "$1=$2" > /dev/null 2>&1
    [ $? -ne 0 ] && { echo "Invalid variable name: $1"; exit 1; }
    case_stmt="$case_stmt) $1=$3; shift ;; "
  fi
}

_shifu_save_remaining_args () {
for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
echo " "
}

_shifu_add_to_help_string() {
  [ -z "$help_string" ] && help_string="$1" || help_string="$help_string\n\n$1"
}
