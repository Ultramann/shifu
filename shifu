# Dependencies: sed

shifu_mode_parse=0
shifu_mode_help=1
shifu_mode_cmds=2

# to see more color options run:
#   for c in {0..15}; do tput setaf $c; tput setaf $c | echo $c: text; done
shifu_grey="$(tput setaf 0)"
shifu_red="$(tput setaf 1)"
shifu_green="$(tput setaf 2)"
shifu_reset="$(tput sgr0)"

shifu_log_flag='--shifu-log'

# Write input arguments to stdout starting with green "shifu"
shifu_log() {
  [ "$shifu_logging" = true ] && echo "${shifu_green}shifu${shifu_reset}  $@"
}

# Write input to stderr
shifu_stderr() {
  echo "$@" >&2
}

# Write input arguments to stderr starting with red "debug"
shifu_debug() {
  shifu_stderr "${shifu_red}debug${shifu_reset}  $@"
}

shifu_var_store() {
  while [ $# -ne 0 ]; do
    eval "${1}_old=\$$1"
    shift
  done
}

shifu_var_restore() {
  while [ $# -ne 0 ]; do
    eval "$1=\$${1}_old; unset -v ${1}_old"
    shift
  done
}

shifu_cmd_name() {
  # 1: command name
  [ $# -ne 1 ] && { echo "Commands cannot contain spaces got: \"$@\""; exit 1; }
  [ $mode -eq $shifu_mode_cmds ] && cmd_name="$1"
}

shifu_cmd_help() {
  # @: help string
  [ $mode -eq $shifu_mode_cmds ] && cmd_help="$@"
}

shifu_cmd_long() {
  # @: long help string
  [ $mode -eq $shifu_mode_cmds ] && cmd_long="$@"
}

shifu_cmd_subs() {
  # @: subcommand function names
  [ $mode -eq $shifu_mode_cmds ] && cmd_subs="$@"
}

shifu_cmd_func() {
  # @: command function name
  [ $mode -eq $shifu_mode_cmds ] && cmd_func="$@"
}

shifu_root_cmds() {
  shifu_cmds="$@"
}

shifu_run() {
  shifu_var_store mode arg cmd cmd_name cmd_help cmd_long cmd_subs cmd_func
  mode=$shifu_mode_cmds
  while [ $# -ne 0 ]; do
    arg="$1"; shift
    arg_matched=''
    for cmd in $shifu_cmds; do
      cmd_name='' cmd_help='' cmd_long='' cmd_subs='' cmd_func=''
      $cmd
      [ "$arg" != "$cmd_name" ] && continue
      arg_matched=true
      [ -n "$cmd_func" ] && break
      shifu_cmds="$cmd_subs"
      break
    done
    [ "$arg_matched" = true -a -n "$cmd_func" ] && break
    [ "$arg_matched" = true -a -n "$cmd_subs" ] && continue
    echo "unknown command: $arg"
    exit 1
  done
  $cmd_func "$@"
  shifu_var_restore mode arg cmd cmd_name cmd_help cmd_long cmd_subs cmd_func
}

shifu_is_arg() {
  [ $# -gt 1 ] && [ "$1" != -- ]
}

shifu_arg() {
  has_options=0
  if [ $shifu_mode -eq $shifu_mode_help ]; then
    while [ $# -ne 1 ]; do shift; done; echo $1; return
  fi
  [ $shifu_mode -ne $shifu_mode_parse ] && return
  shifu_is_arg "$@" && { has_options=1; case_stmt="$case_stmt $1"; shift; }
  while shifu_is_arg "$@"; do
    case_stmt="${case_stmt}|$1"; shift
  done; shift
  # remaining
  if [ $# -eq 1 ]; then
    parse_stage=2
  # positional
  elif [ $has_options -eq 0 ]; then
    if [ $parse_stage -lt 1 ]; then
      parse_stage=1
      case_stmt="$case_stmt -*|--*) echo 'Invalid option $1'; exit 1 ;; "
      case_stmt="$case_stmt *)"
    elif [ $parse_stage -gt 1 ]; then
      echo "No arguments after remaining are declared: $1"; exit 1;
    fi
    eval "$1=" > /dev/null 2>&1
    [ $? -ne 0 ] && { echo "Invalid variable name: $1"; exit 1; }
    case_stmt="$case_stmt [ \$# -eq 0 ] && { echo 'Missing positional argument $1'; exit 1; }; "
    case_stmt="$case_stmt $1=\$1; shift; "
  # option + argument without default
  elif [ $# -eq 2 ]; then
    [ $parse_stage -gt 0 ] && { echo "No options after positional/remaining arguments: $1"; exit 1; }
    eval "$1=" > /dev/null 2>&1
    [ $? -ne 0 ] && { echo "Invalid variable name: $1"; exit 1; }
    case_stmt="$case_stmt) $1=\$2; shift; shift ;; "
  # option + argument with default
  elif [ $# -eq 3 ]; then
    [ $parse_stage -gt 0 ] && { echo "No options after positional/remaining arguments: $1"; exit 1; }
    eval "$1=$2" > /dev/null 2>&1
    [ $? -ne 0 ] && { echo "Invalid variable name: $1"; exit 1; }
    case_stmt="$case_stmt) $1=\$2; shift; shift ;; "
  # option no argument default set
  elif [ $# -eq 4 ]; then
    [ $parse_stage -gt 0 ] && { echo "No options after positional/remaining arguments: $1"; exit 1; }
    eval "$1=$2" > /dev/null 2>&1
    [ $? -ne 0 ] && { echo "Invalid variable name: $1"; exit 1; }
    case_stmt="$case_stmt) $1=$3; shift ;; "
  fi
}

shifu_save_remaining_args () {
for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
echo " "
}

shifu_parse_args() {
  # 1: function, 2-: args to parse
  shifu_var_store shifu_mode parse_stage case_stmt has_options
  shifu_mode=$shifu_mode_parse
  parse_stage=0
  case_stmt="case \$1 in"
  $1; shift # run the cmd function
  [ $parse_stage -eq 0 ] && case_stmt="$case_stmt *) "
  case_stmt="$case_stmt break ;; esac"
  while true; do
    eval "$case_stmt"
  done
  shifu_remaining_args=$(shifu_save_remaining_args "$@")
  shifu_var_restore shifu_mode parse_stage case_stmt has_options
}

shifu_help() {
  shifu_mode=$shifu_mode_help
  $1
}
