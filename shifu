# Dependencies: sed

shifu_mode_cmds=0
shifu_mode_args=1
shifu_mode_help=2

# to see more color options run:
#   for c in {0..15}; do tput setaf $c; tput setaf $c | echo $c: text; done
shifu_grey="$(tput setaf 0)"
shifu_red="$(tput setaf 1)"
shifu_green="$(tput setaf 2)"
shifu_reset="$(tput sgr0)"

shifu_log_flag='--shifu-log'

shifu_cmd_name() {
  # 1: command name
  [ $# -ne 1 ] && { echo "Commands cannot contain spaces got: \"$@\""; exit 1; }
  [ $mode -ne $shifu_mode_args ] && cmd_name="$1"
}

shifu_cmd_help() {
  # @: help string
  [ $mode -ne $shifu_mode_args ] && cmd_help="$@"
}

shifu_cmd_long() {
  # @: long help string
  [ $mode -ne $shifu_mode_args ] && cmd_long="$@"
}

shifu_cmd_subs() {
  # @: subcommand function names
  [ $mode -ne $shifu_mode_args ] && cmd_subs="$@"
}

shifu_cmd_func() {
  # @: command function name
  [ $mode -ne $shifu_mode_args ] && cmd_func="$@"
}

shifu_arg() {
  case $mode in
    $shifu_mode_help) _shifu_arg_help "$@" ;;
    $shifu_mode_args) _shifu_parse_arg "$@" ;;
    *) return
  esac
}

shifu_run() {
  shifu_var_store mode parent arg arg_matched cmd cmd_name cmd_help cmd_long cmd_subs cmd_func
  mode=$shifu_mode_cmds
  parent="$1"; shift; "$parent"; shifu_cmds="$cmd_subs"
  while [ $# -ne 0 ]; do
    arg="$1"; shift
    arg_matched=''
    for cmd in $shifu_cmds; do
      _shifu_clear_cmd_vars
      "$cmd"
      [ "$arg" != "$cmd_name" ] && continue
      arg_matched=true
      [ -n "$cmd_func" ] && break
      parent="$cmd"
      shifu_cmds="$cmd_subs"
      break
    done
    [ "$arg_matched" = true -a -n "$cmd_func" ] && break
    [ "$arg_matched" = true -a -n "$cmd_subs" ] && continue
    echo "unknown command: $arg"
    shifu_help "$parent"
    exit 1
  done
  [ "$1" = "-h" -o "$1" = "--help" ] && shifu_help "$cmd" || "$cmd_func" "$@"
  shifu_var_restore mode parent arg arg_matched cmd cmd_name cmd_help cmd_long cmd_subs cmd_func
}

shifu_parse_args() {
  # 1: function, 2-: args to parse
  shifu_var_store mode parse_stage case_stmt has_options
  mode=$shifu_mode_args
  parse_stage=0
  case_stmt="case \$1 in -h|--help) shifu_help \$1; break ;; "
  "$1"; shift # run the cmd function
  [ $parse_stage -eq 0 ] && case_stmt="$case_stmt *) "
  case_stmt="$case_stmt break ;; esac"
  while true; do
    eval "$case_stmt"
  done
  shifu_remaining_args=$(_shifu_save_remaining_args "$@")
  shifu_var_restore mode parse_stage case_stmt has_options
}

shifu_help() {
  shifu_var_store mode help_stage help_usage help_arguments help_options help_string has_options
  mode=$shifu_mode_help
  _shifu_clear_cmd_vars
  help_stage=0 help_usage='' help_arguments='' help_options='' help_string=''
  "$1"
  [ -n "$help_usage" ] && help_usage="$cmd_name [OPTIONS] $help_usage"
  [ -n "$cmd_help" ] && _shifu_add_to_help_string "$cmd_help"
  [ -n "$cmd_long" ] && _shifu_add_to_help_string "$cmd_long"
  [ -n "$help_usage" ] && _shifu_add_to_help_string "Usage\n\t$help_usage"
  [ -n "$help_arguments" ] && _shifu_add_to_help_string "Arguments\n$help_arguments"
  [ -n "$help_options" ] && _shifu_add_to_help_string "Options\n$help_options"
  [ -n "$help_string" ] && echo "$help_string"
  shifu_var_restore mode help_stage help_usage help_arguments help_options help_string has_options
}

# Write input arguments to stdout starting with green "shifu"
shifu_log() {
  [ "$shifu_logging" = true ] && echo "${shifu_green}shifu${shifu_reset}  $@"
}

# Write input to stderr
shifu_stderr() {
  echo "$@" >&2
}

# Write input arguments to stderr starting with red "debug"
shifu_debug() {
  shifu_stderr "${shifu_red}debug${shifu_reset}  $@"
}

shifu_var_store() {
  while [ $# -ne 0 ]; do
    [ -z "$1" ] && { shift; continue; }
    eval "[ -z \$shifu_${1}_shifu ] && shifu_${1}_shifu=\$$1 || \\
          { echo \"Cannot use variable 'shifu_${1}_shifu'\"; exit 1; }"
    shift
  done
}

shifu_var_restore() {
  while [ $# -ne 0 ]; do
    eval "$1=\$shifu_${1}_shifu; unset -v shifu_${1}_shifu"
    shift
  done
}

_shifu_clear_cmd_vars() {
    cmd_name='' cmd_help='' cmd_long='' cmd_subs='' cmd_func=''
}

_shifu_arg_help() {
  has_options=0
  [ $# -gt 1 -a "$1" != -- ] && { has_options=1; help_options="$help_options $1"; shift; }
  while [ $# -gt 1 -a "$1" != -- ]; do help_options="$help_options, $1"; done; shift
 # remaining
  if [ $# -eq 1 ]; then
    help_stage=2
    help_usage="$help_usage ..."
    help_arguments="$help_arguments\nRemaining\n\t$1"
  # positional
  elif [ $has_options -eq 0 ]; then
    if [ $help_stage -lt 1 ]; then
      help_stage=1
    elif [ $help_stage -gt 1 ]; then
      echo "No arguments after remaining are declared: $1"; exit 1;
    fi
    help_usage="$help_usage $1"
    help_arguments="$help_arguments\n$1\n$2"
  # option + argument without default
  elif [ $# -eq 2 ]; then
    [ $help_stage -gt 0 ] && { echo "No options after positional/remaining arguments: $1"; exit 1; }
    help_options="\t [$1]\n\t$2"
  # option + argument with default
  elif [ $# -eq 3 ]; then
    [ $parse_stage -gt 0 ] && { echo "No options after positional/remaining arguments: $1"; exit 1; }
    help_options="\t [$1]\n\t$3. Default: $2."
  # option no argument default set
  elif [ $# -eq 4 ]; then
    [ $parse_stage -gt 0 ] && { echo "No options after positional/remaining arguments: $1"; exit 1; }
    help_options="\n\t$4. Options: $2, $3. Default: $2."
  fi
}

_shifu_parse_arg() {
  has_options=0
  [ $# -gt 1 -a "$1" != -- ] && { has_options=1; case_stmt="$case_stmt $1"; shift; }
  while [ $# -gt 1 -a "$1" != -- ]; do
    case_stmt="${case_stmt}|$1"; shift
  done; shift
  # remaining
  if [ $# -eq 1 ]; then
    parse_stage=2
  # positional
  elif [ $has_options -eq 0 ]; then
    if [ $parse_stage -lt 1 ]; then
      parse_stage=1
      case_stmt="$case_stmt -*|--*) echo 'Invalid option $1'; exit 1 ;; "
      case_stmt="$case_stmt *)"
    elif [ $parse_stage -gt 1 ]; then
      echo "No arguments after remaining are declared: $1"; exit 1;
    fi
    eval "$1=" > /dev/null 2>&1
    [ $? -ne 0 ] && { echo "Invalid variable name: $1"; exit 1; }
    case_stmt="$case_stmt [ \$# -eq 0 ] && { echo 'Missing positional argument $1'; exit 1; }; "
    case_stmt="$case_stmt $1=\$1; shift; "
  # option + argument without default
  elif [ $# -eq 2 ]; then
    [ $parse_stage -gt 0 ] && { echo "No options after positional/remaining arguments: $1"; exit 1; }
    eval "$1=" > /dev/null 2>&1
    [ $? -ne 0 ] && { echo "Invalid variable name: $1"; exit 1; }
    case_stmt="$case_stmt) $1=\$2; shift; shift ;; "
  # option + argument with default
  elif [ $# -eq 3 ]; then
    [ $parse_stage -gt 0 ] && { echo "No options after positional/remaining arguments: $1"; exit 1; }
    eval "$1=$2" > /dev/null 2>&1
    [ $? -ne 0 ] && { echo "Invalid variable name: $1"; exit 1; }
    case_stmt="$case_stmt) $1=\$2; shift; shift ;; "
  # option no argument default set
  elif [ $# -eq 4 ]; then
    [ $parse_stage -gt 0 ] && { echo "No options after positional/remaining arguments: $1"; exit 1; }
    eval "$1=$2" > /dev/null 2>&1
    [ $? -ne 0 ] && { echo "Invalid variable name: $1"; exit 1; }
    case_stmt="$case_stmt) $1=$3; shift ;; "
  fi
}

_shifu_save_remaining_args () {
for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
echo " "
}

_shifu_add_to_help_string() {
  [ -z "$help_string" ] && help_string="$1" || help_string="$help_string\n\n$1"
}
