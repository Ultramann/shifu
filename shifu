shifu_command_function_pattern='^(.*) ?\(\) {'
shifu_uscore='_'
shifu_space=' '

# for c in {0..15}; do tput setaf $c; tput setaf $c | echo $c: text; done
shifu_grey="$(tput setaf 0)"
shifu_red="$(tput setaf 1)"
shifu_green="$(tput setaf 2)"
shifu_reset="$(tput sgr0)"

shifu_log_flag='--shifu-log'

# Write input arguments to stdout starting with green "shifu"
shifu_log() {
  [ "$shifu_logging" = true ] && echo "${shifu_green}shifu${shifu_reset}  $@"
}

# Write input to stderr
shifu_stderr() {
  echo "$@" >&2
}

# Write input arguments to stderr starting with red "debug"
shifu_debug() {
  shifu_stderr "${shifu_red}debug${shifu_reset}  $@"
}

shifu_count_char() {
  printf $(tr -cd "$1" | wc -c)
}

# Convert spaces to newlines to enable looping
shifu_iterate() {
  printf "$1\n" | tr ' ' '\n'
}

# Convert newlines to spaces
shifu_collapse() {
  printf "$1" | tr '\n' ' '
}

# Write newline separated "array" as "( arg1 arg2 ... argn )" to stdout
shifu_array_fmt() {
  printf "( $(shifu_collapse "$1") )"
}

# Write number of elements in newline separated "array" to stdout
shifu_array_length() {
  shifu_iterate "$1" | wc -l
}

# Write newline separated "array" with element added at end to stdout
shifu_array_append() {
  local array="$1"
  local element="$2"
  [ "${#array}" -gt 0 ] && { echo "$array"; echo "$element"; } || echo "$element"
}

# Test if newline separated array contains first argument,
# write true to stdout if found, else false. Examples
# [argument other arg] arg -> true
# [argument other arg] no -> false
shifu_array_contains() {
  local array="$1"
  local value="$2"
  local element
  for element in $(shifu_iterate "$array"); do
    [ "$element" = "$value" ] && { echo true; return; }
  done
  echo false
}

# Filter newline separated "array" by words containing first argment as prefix,
# write matching elements to stdout. Examples
#   [argument other arg3] arg -> "argument arg3"
#   [argument other arg3] oth -> "other"
shifu_array_filter_prefix() {
  local array="$1"
  local prefix="$2"
  [ -z "$prefix" ] && { echo "$array"; return; }
  local element
  for element in $(shifu_iterate "$array"); do
    [ "${element#"$prefix"}" != "$element" ] && echo "$element"
  done
}

# Write the absolute path of the calling script, $0, to stdout
shifu_caller_script() {
  echo $(realpath $(basename $0))
}

# Reads function names in passed script path matching the regex pattern
# shifu_command_function_pattern to global variable `script_functions`
shifu_read_script_functions() {
  local script_path="$1"
  script_functions=$(
    cat "${script_path}" | \
    # -r: extended regex, -n: don't echo lines to stdout
    sed -rn "/$shifu_command_function_pattern/!d;
            s/$shifu_command_function_pattern/\1/p"
  )
}

# This must be passed actual positional arguments
shifu_determine_function_to_call() {
  local uscore_candidate=""
  local spaced_candidate=""
  local filtered_functions="$script_functions"
  local argument
  for argument in "$@"; do
    tmp_functions=$(shifu_array_filter_prefix "$filtered_functions" "$uscore_candidate")
    [ $(shifu_array_length "$tmp_functions") -le 1 ] && break
    uscore_candidate="${uscore_candidate}${argument}${shifu_uscore}"
    spaced_candidate="${spaced_candidate}${argument}${shifu_space}"
    filtered_functions="$tmp_functions"
  done

  local candidate_function="${uscore_candidate%$shifu_uscore}"
  local found_function=$(shifu_array_contains "$script_functions" "$candidate_function")

  shifu_log filtered functions: $(shifu_array_fmt "$filtered_functions")
  shifu_log candidate function: "$candidate_function"

  if [ "$found_function" = true ]; then
    function_to_call="$candidate_function"
    arguments_in_function="${spaced_candidate%$shifu_space}"
    shifu_log function to call: "$function_to_call"
    return 0
  # todo: have branch for when function found and arg is --help
  else
    local unknown_subcommand="${candidate_function##*$shifu_uscore}"
    local parsed_arguments="${spaced_candidate%$shifu_space*$shifu_space}"
    shifu_stderr "$parsed_arguments has no subcommand $unknown_subcommand"
    return 1
  fi

}

shifu_function_to_call_argument_length() {
  echo "$arguments_in_function" | tr -sc "$shifu_space" "*" | tr -d "$shifu_space" | wc -m
}

shifu_run() {
  [ "$1" = "$shifu_log_flag" ] && { shifu_logging=true; shift; }

  local script_functions
  shifu_read_script_functions $(shifu_caller_script)

  local function_to_call
  local arguments_in_function
  shifu_determine_function_to_call "$@"; status=$?
  [ $status != 0 ] && return $status

  # shift input arguments function length to leave intended arguments
  for i in $(seq 1 $(shifu_function_to_call_argument_length)); do shift; done;

  $function_to_call "$@"
}

