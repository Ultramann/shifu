shifu_command_function_declaration='^(.*) ?\(\) {'
shifu_subcommand_delimiter='_'

# for c in {0..15}; do tput setaf $c; tput setaf $c | echo $c: text; done
shifu_grey="$(tput setaf 0)"
shifu_red="$(tput setaf 1)"
shifu_green="$(tput setaf 2)"
shifu_reset="$(tput sgr0)"

shifu_log_flag='--shifu-log'

# Write input arguments to stdout starting with green "shifu"
shifu_log() {
  [ "${shifu_logging_on}" = true ] && echo "${shifu_green}shifu${shifu_reset}  $*"
}

# Write input to stderr
shifu_stderr() {
  echo "$*" >&2
}

# Write input arguments to stderr starting with red "debug"
shifu_debug() {
  shifu_stderr "${shifu_red}debug${shifu_reset}  $*"
}

# Convert spaces to newlines to enable looping
shifu_iterate() {
  echo $1 | tr ' ' '\n'
}

# Convert newlines to spaces
shifu_collapse() {
  echo $1 | tr '\n' ' '
}

# Write newline separated "array" as "( arg1 arg2 ... argn )" to stdout
shifu_array_fmt() {
  echo "( $(shifu_collapse "$1"))"
}

# Write number of elements in newline separated "array" to stdout
shifu_array_length() {
  local array=$1
  shifu_iterate "$array" | wc -l
}

# Write newline separated "array" with element added at end to stdout
shifu_array_append() {
  local array=$1
  local element=$2
  [ "${#array}" -gt 0 ] && echo "$array\n$element" || echo "$element"
}

# Test if newline separated array contains first argument,
# write true to stdout if found. Examples
# [argument other arg] arg -> true
# [argument other arg] nar -> false
shifu_array_contains() {
  local array=$1
  local value=$2
  local element
  for element in $(shifu_iterate "$array"); do
    [ "$element" = "$value" ] && { echo true; break; }
  done
}

# Filter newline separated "array" by words containing first argment as prefix,
# write matching elements to stdout. Examples
#   [argument other arg3] arg -> "argument arg3"
#   [argument other arg3] oth -> "other"
shifu_array_filter_prefix() {
  local array=$1
  local prefix=$2
  [ -z "$prefix" ] && { echo "$array"; return; }
  local element
  for element in $(shifu_iterate "$array"); do
    [ "${element#"$prefix"}" != "$element" ] && echo "$element"
  done
}

# Write the absolute path of the calling script, $0, to stdout
shifu_caller_script() {
  echo $(realpath $(basename $0))
}

# Reads function names in passed script path matching the regex pattern
# shifu_command_function_pattern to global variable `script_functions`
shifu_read_script_functions() {
  local script_path=$1
  script_functions=$(
    cat "${script_path}" | \
    # -r: extended regex, -n: don't echo lines to stdout
    sed -rn "/${shifu_command_function_pattern}/!d;
            s/${shifu_command_function_pattern}/\1/p"
  )
}

shifu_infer_function_and_arguments() {
  local array=$1

  function_to_call=""
  remaining_arguments=""

  local candidate=""
  local filtered_functions="$script_functions"
  local argument
  for argument in $(shifu_iterate "$array"); do
    filtered_functions=$(shifu_array_filter_prefix "$filtered_functions" "$candidate")
    if [ $(shifu_array_length "$filtered_functions") -le 1 ]; then
      remaining_arguments=$(shifu_array_append "$remaining_arguments" "$argument")
    else
      candidate="${candidate}${argument}${shifu_subcommand_delimiter}"
    fi
  done
  remaining_arguments=$(shifu_collapse "$remaining_arguments")

  local maybe_function="${candidate%${shifu_subcommand_delimiter}}"
  local found_function=$(shifu_array_contains "$script_functions" "$maybe_function")

  shifu_log maybe function: "$maybe_function"
  shifu_log maybe function arguments: $(shifu_array_fmt "$remaining_arguments")

  if [ "$found_function" = true ]; then
    function_to_call="$maybe_function"
    shifu_log function to call: "$function_to_call"
    return 0
  else
    local parsed_candidate=$(echo ${candidate%_*_} | tr '_' ' ')
    shifu_stderr "$parsed_candidate has no subcommand ${maybe_function##*_}"
    return 1
  fi

}

shifu_run() {
  [ $1 = "${shifu_log_flag}" ] && { shifu_logging_on=true; shift; }

  shifu_read_script_functions $(shifu_caller_script)

  shifu_infer_function_and_arguments "$*"; status=$?
  [ $status != 0 ] && return $status

  eval "$function_to_call $remaining_arguments"
}

