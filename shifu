#! /bin/sh

shifu_mode_cmds=1
shifu_mode_args=2
shifu_mode_help=3
shifu_mode_cmds_comp=4

shifu_cmd_name() {
  [ $# -ne 1 ] && _shifu_error "Commands cannot contain spaces got: \"$@\""
  [ ${shifu_mode:-0} -ne $shifu_mode_args ] && shifu_cmd_name="$1"
}

shifu_cmd_help() {
  [ ${shifu_mode:-0} -ne $shifu_mode_args ] && shifu_cmd_help="$@"
}

shifu_cmd_long() {
  [ ${shifu_mode:-0} -ne $shifu_mode_args ] && shifu_cmd_long="$@"
}

shifu_cmd_subs() {
  [ ${shifu_mode:-0} -ne $shifu_mode_args ] && shifu_cmd_subs="$@"
}

shifu_cmd_func() {
  [ ${shifu_mode:-0} -ne $shifu_mode_args ] && shifu_cmd_func="$@"
}

shifu_cmd_arg() {
  case ${shifu_mode:-0} in
    $shifu_mode_help)
      [ -z "${shifu_cmd_subs:-}" ] && _shifu_arg_help "$@" ;;
    $shifu_mode_args)
      [ -z "${shifu_cmd_subs:-}" ] && _shifu_parse_arg "$@" || _shifu_handle_arg_global "$@" ;;
  esac
}

shifu_cmd_arg_loc() {
  case $shifu_mode in
    $shifu_mode_help) _shifu_arg_help "$@" ;;
    $shifu_mode_args) _shifu_parse_arg "$@" ;;
  esac
}

shifu_less() {
  cmd_name()    { shifu_cmd_name "$@"; }
  cmd_help()    { shifu_cmd_help "$@"; }
  cmd_long()    { shifu_cmd_long "$@"; }
  cmd_subs()    { shifu_cmd_subs "$@"; }
  cmd_func()    { shifu_cmd_func "$@"; }
  cmd_arg()     { shifu_cmd_arg "$@"; }
  cmd_arg_loc() { shifu_cmd_arg_loc "$@"; }
}

shifu_run() {
  case "$2" in
    --tab-completion) _shifu_generate_tab_completion "$@" ;;
    --shifu-complete) _shifu_complete "$@" ;;
    *) _shifu_run "$@" ;;
  esac
}

_shifu_run() {
  shifu_mode=$shifu_mode_cmds
  shifu_parent="$1"; shifu_cmd="$1"; shift
  "$shifu_parent"
  _shifu_set_for_looping shifu_cmds shifu_cmd_subs
  while [ $# -ne 0 -a -n "${shifu_cmd_subs:-}" ]; do
    _shifu_parse_args true "$shifu_parent" "$@"
    shifu_mode=$shifu_mode_cmds
    shift $_shifu_args_parsed
    shifu_arg_matched=''
    for shifu_cmd in $shifu_cmds; do
      _shifu_clear_cmd_vars
      "$shifu_cmd"
      [ "$1" != "$shifu_cmd_name" ] && continue
      shifu_arg_matched=true; shift
      [ -n "$shifu_cmd_func" ] && break
      shifu_parent="$shifu_cmd"
      _shifu_set_for_looping shifu_cmds shifu_cmd_subs
      break
    done
    [ "$shifu_arg_matched" = true -a -n "$shifu_cmd_func" ] && break
    [ "$shifu_arg_matched" = true -a -n "$shifu_cmd_subs" ] && continue
    [ "$1" != "-h" -a "$1" != "--help" ] && echo "Unknown command: $1"
    _shifu_help "$shifu_parent" 1
  done
  [ -z "$shifu_cmd_func" ] && { echo "$shifu_cmd_name requires arguments"; _shifu_help "$shifu_cmd" 1; }
  [ "$1" = "-h" -o "$1" = "--help" ] && _shifu_help "$shifu_cmd" 0
  _shifu_parse_args false "$shifu_cmd" "$@"
  shift $_shifu_args_parsed
  "$shifu_cmd_func" "$@"
}

_shifu_parse_args() {
  shifu_mode=$shifu_mode_args
  shifu_parse_stage=0
  shifu_parse_local="$1"; shifu_cmd="$2"; shift 2
  shifu_case_stmt="case \"\$1\" in ${shifu_global_case:-} -h|--help) _shifu_help \"$shifu_cmd\" 0 ;; "
  "$shifu_cmd"
  shifu_parse_local=''
  [ $shifu_parse_stage -eq 0 ] && _shifu_update_case_stmt_invalid_option
  shifu_case_stmt="$shifu_case_stmt break ;; esac"
  _shifu_args_parsed=0
  while true; do
    eval "$shifu_case_stmt"
  done
}

_shifu_parse_arg() {
  shifu_no_options=true
  if [ "$1" != -- ]; then
    shifu_no_options=''
    shifu_case_stmt="$shifu_case_stmt $1"
    shift
  fi
  while [ $# -gt 1 -a "$1" != -- ]; do
    shifu_case_stmt="${shifu_case_stmt}|$1"; shift
  done; shift
  # remaining
  if [ $# -eq 1 ]; then
    [ "$shifu_parse_local" = true ] && _shifu_error "Remaining arguments cannot be local: $1"
    [ $shifu_parse_stage -eq 0 ] && _shifu_update_case_stmt_invalid_option
    shifu_parse_stage=2
  # positional
  elif [ "$shifu_no_options" = true ]; then
    [ "$shifu_parse_local" = true ] && _shifu_error "Positional arguments cannot be local: $1"
    if [ $shifu_parse_stage -eq 0 ]; then
      shifu_parse_stage=1
      _shifu_update_case_stmt_invalid_option
    elif [ $shifu_parse_stage -gt 1 ]; then
      _shifu_error "No arguments after remaining are declared: $1"
    fi
    _shifu_set_variable "$1" ""
    shifu_case_stmt="$shifu_case_stmt [ \$# -eq 0 ] && _shifu_error 'Missing positional argument $1'; "
    shifu_case_stmt="$shifu_case_stmt $1=\$1; shift; _shifu_ack_arg; "
  # option + argument without default
  elif [ $# -eq 2 ]; then
    _shifu_error_if_invalid_arg_order "$1" $shifu_parse_stage
    _shifu_set_variable "$1" ""
    shifu_case_stmt="$shifu_case_stmt) $1=\$2; shift 2; _shifu_ack_arg 2 ;; "
  # option + argument with default
  elif [ $# -eq 3 ]; then
    _shifu_error_if_invalid_arg_order "$1" $shifu_parse_stage
    _shifu_set_variable "$1" "$2"
    shifu_case_stmt="$shifu_case_stmt) $1=\$2; shift 2; _shifu_ack_arg 2 ;; "
  # option no argument, default-set
  elif [ $# -eq 4 ]; then
    _shifu_error_if_invalid_arg_order "$1" $shifu_parse_stage
    _shifu_set_variable "$1" "$2"
    shifu_case_stmt="$shifu_case_stmt) $1=$3; shift; _shifu_ack_arg ;; "
  fi
}

_shifu_handle_arg_global() {
  shifu_no_options=true
  if [ "$1" != -- ]; then
    shifu_no_options=''
    shifu_global_case="${shifu_global_case:-} $1"
    shifu_global_help="${shifu_global_help:-}\n  $1"
    shift
  fi
  while [ $# -gt 1 -a "$1" != -- ]; do
    shifu_global_case="${shifu_global_case:-}|$1"
    shifu_global_help="${shifu_global_help:-}, $1"
    shift
  done; shift
  # remaining
  if [ $# -eq 1 ]; then
    _shifu_error "Remaining arguments cannot be global"
  # positional
  elif [ "$shifu_no_options" = true ]; then
    _shifu_error "Positional arguments cannot be global: $1"
  # option + argument without default
  elif [ $# -eq 2 ]; then
    _shifu_set_variable "$1" ""
    shifu_global_case="${shifu_global_case:-}) $1=\$2; shift 2; _shifu_ack_arg 2 ;; "
    shifu_global_help="${shifu_global_help:-} $1\n    $2"
  # option + argument with default
  elif [ $# -eq 3 ]; then
    _shifu_set_variable "$1" "$2"
    shifu_global_case="${shifu_global_case:-}) $1=\$2; shift 2; _shifu_ack_arg 2 ;; "
    shifu_global_help="${shifu_global_help:-} $1\n    $3\n    Default: $2"
  # option no argument, default-set
  elif [ $# -eq 4 ]; then
    _shifu_set_variable "$1" "$2"
    shifu_global_case="${shifu_global_case:-}) $1=$3; shift; _shifu_ack_arg ;; "
    shifu_global_help="${shifu_global_help:-}\n    $4\n    Default: $2, set: $3"
  fi
}

_shifu_ack_arg() {
  _shifu_args_parsed=$((_shifu_args_parsed + ${1:-1}))
}

_shifu_clear_cmd_vars() {
    shifu_cmd_name='' shifu_cmd_help='' shifu_cmd_long='' shifu_cmd_subs='' shifu_cmd_func=''
}

_shifu_help() {
  "$1"
  shifu_mode=$shifu_mode_help
  _shifu_make_subcmd_help
  _shifu_clear_cmd_vars
  shifu_help_stage=0 shifu_help_usage='' shifu_help_arguments='' shifu_help_options='' shifu_help_string=''
  "$1"
  [ -n "$shifu_cmd_func" ] && shifu_help_options="$shifu_help_options${shifu_global_help:-}"
  shifu_help_options="$shifu_help_options\n  -h, --help\n    Show this help"
  [ -n "$shifu_help_usage" ] && shifu_help_usage="$shifu_cmd_name [OPTIONS]$shifu_help_usage"
  [ -n "$shifu_cmd_help" ] && _shifu_add_to_help_string "$shifu_cmd_help"
  [ -n "$shifu_cmd_long" ] && _shifu_add_to_help_string "$shifu_cmd_long"
  [ -n "$shifu_help_usage" ] && _shifu_add_to_help_string "Usage\n  $shifu_help_usage"
  [ -n "$shifu_help_arguments" ] && _shifu_add_to_help_string "Arguments$shifu_help_arguments"
  [ -n "${shifu_subcmd_help:-}" ] && _shifu_add_to_help_string "Subcommands$shifu_subcmd_help"
  [ -n "$shifu_help_options" ] && _shifu_add_to_help_string "Options$shifu_help_options"
  [ -n "$shifu_help_string" ] && printf "$shifu_help_string\n"
  exit $2
}

_shifu_add_to_help_string() {
  [ -z "$shifu_help_string" ] && shifu_help_string="$1" || shifu_help_string="$shifu_help_string\n\n$1"
}

_shifu_make_subcmd_help() {
  [ -z "${shifu_cmd_subs:-}" ] && return
  _shifu_set_for_looping shifu_subcmds shifu_cmd_subs
  _shifu_clear_cmd_vars
  for shifu_subcmd in $shifu_subcmds; do
    shifu_help_stage=0
    "$shifu_subcmd"
    shifu_subcmd_help="${shifu_subcmd_help:-}\n  $shifu_cmd_name"
    [ -n "${shifu_cmd_help:-}" ] && shifu_subcmd_help="${shifu_subcmd_help:-}\n    $shifu_cmd_help"
  done
}

_shifu_arg_help() {
  shifu_no_options=true
  if [ "$1" != -- ]; then
    shifu_no_options=''
    shifu_help_options="$shifu_help_options\n  $1"
    shift
  fi
  while [ $# -gt 1 -a "$1" != -- ]; do
    shifu_help_options="$shifu_help_options, $1"; shift
  done; shift
 # remaining
  if [ $# -eq 1 ]; then
    shifu_help_stage=2
    shifu_help_usage="$shifu_help_usage ...[REMAINING]"
    shifu_help_arguments="$shifu_help_arguments\n  REMAINING\n    $1"
  # positional
  elif [ "$shifu_no_options" = true ]; then
    if [ $shifu_help_stage -lt 1 ]; then
      shifu_help_stage=1
    elif [ $shifu_help_stage -gt 1 ]; then
      _shifu_error "No arguments after remaining are declared: $1"
    fi
    shifu_help_usage="$shifu_help_usage [$1]"
    shifu_help_arguments="$shifu_help_arguments\n  $1\n    $2"
  # option + argument without default
  elif [ $# -eq 2 ]; then
    _shifu_error_if_invalid_arg_order "$1" $shifu_help_stage
    shifu_help_options="$shifu_help_options [$1]\n    $2"
  # option + argument with default
  elif [ $# -eq 3 ]; then
    _shifu_error_if_invalid_arg_order "$1" $shifu_help_stage
    shifu_help_options="$shifu_help_options [$1]\n    $3\n    Default: $2"
  # option no argument default set
  elif [ $# -eq 4 ]; then
    _shifu_error_if_invalid_arg_order "$1" $shifu_help_stage
    shifu_help_options="$shifu_help_options\n    $4\n    Default: ${2:-empty}, set: $3"
  fi
}

_shifu_generate_tab_completion() {
  shifu_mode=$shifu_mode_cmds
  "$1"
  case "$3" in
    zsh) _shifu_generate_zsh_tab_completion "$@";;
    bash) _shifu_generate_bash_tab_completion "$@";;
    help) _shifu_tab_completion_help ;;
    *) echo "Unknown shell, $3, cannot perform tab completion"; exit 1 ;;
  esac
}

_shifu_tab_completion_help() {
  echo "Generate tab completion code for specified shell

Instructions
1. Ensure $shifu_cmd_name is in a directory on your shell's PATH
2. Ensure $shifu_cmd_name has access to shifu; either by putting
   shifu in the same PATH directory as $shifu_cmd_name or adding
   shifu to another PATH directory
3. If you're using zsh, ensure that you've loaded and run
   compinit before the following eval call in your zshrc file
4. Add the following to your shell's rc file
     eval \"\$($shifu_cmd_name --tab-completion <shell>)\"
   replacing <shell> with your shell. Supported shells:
     zsh, bash"
}

_shifu_generate_zsh_tab_completion() {
  echo "_${shifu_cmd_name}_completion() {
  current=\"\${words[\$CURRENT]}\"
  full_words=( \"\${words[@]:1:\${#words[@]}-2}\" )
  compadd -q -- \$($shifu_cmd_name --shifu-complete \"\$current\" \"\${full_words[@]}\")
}
compdef _${shifu_cmd_name}_completion $shifu_cmd_name"
}

_shifu_generate_bash_tab_completion() {
  echo "_${shifu_cmd_name}_completion() {
  current=\"\${COMP_WORDS[\${#COMP_WORDS[@]}-1]}\"
  full_words=( \"\${COMP_WORDS[@]:1:\${#COMP_WORDS[@]}-2}\" )
  completions=\$($shifu_cmd_name --shifu-complete \"\$current\" \"\${full_words[@]}\")
  COMPREPLY=( \$(compgen -W \"\$completions\" -- \"\$current\") )
}
complete -F _${shifu_cmd_name}_completion $shifu_cmd_name"
}

_shifu_complete() {
  shifu_mode=$shifu_mode_cmds_comp
  shifu_parent="$1"; shifu_cmd="$1"; shifu_current_word="$3"; shift 3
  "$shifu_parent"
  _shifu_set_for_looping shifu_cmds shifu_cmd_subs
  while [ $# -ne 0 -a -n "${shifu_cmd_subs:-}" ]; do
    shifu_parse_local=true
    shifu_mode=$shifu_mode_cmds_comp
    shifu_arg_matched=''
    for shifu_cmd in $shifu_cmds; do
      _shifu_clear_cmd_vars
      "$shifu_cmd"
      [ "$1" != "$shifu_cmd_name" ] && continue
      shifu_arg_matched=true; shift
      [ -n "$shifu_cmd_func" ] && break
      shifu_parent="$shifu_cmd"
      _shifu_set_for_looping shifu_cmds shifu_cmd_subs
      break
    done
  done
  [ -n "${shifu_cmd_func:-}" ] && _shifu_complete_func_args
  [ $# -eq 0 ] && _shifu_complete_subcmd_names
}

_shifu_complete_func_args() {
  exit
}

_shifu_complete_subcmd_names() {
  "$shifu_parent"
  _shifu_set_for_looping shifu_cmds shifu_cmd_subs
  for shifu_cmd in $shifu_cmds; do
    "$shifu_cmd"
    _shifu_add_completion "$shifu_cmd_name"
  done
  echo "$shifu_completions"
  exit
}

_shifu_add_completion() {
    if [ -z "${shifu_completions:-}" ]; then
      shifu_completions="$1"
    else
      shifu_completions="$shifu_completions $1"
    fi
}

_shifu_update_case_stmt_invalid_option() {
  shifu_case_stmt="$shifu_case_stmt
    -*|--*) echo \"Invalid option: \$1\"; _shifu_help \"\$shifu_cmd\" 1 ;;
    *)"
}

_shifu_set_for_looping() {
  eval "[ -z \"\${$2:-}\" ] && { $1=''; return; }"
  if [ -n "${ZSH_VERSION:-}" ]; then
    eval "$1=( \${=$2} )"
  else
    eval "$1=\$$2"
  fi
}

_shifu_set_variable() {
  eval "$1=\"$2\"" > /dev/null 2>&1
  [ $? -eq 0 ] && return 0
  _shifu_error "Invalid variable name: $1"
}

_shifu_error_if_invalid_arg_order() {
  [ $2 -eq 0 ] && return
  _shifu_error "No options after positional/remaining arguments: $1"
}

_shifu_error() {
  echo "$1"
  exit 1
}

_shifu_trace() {
  if [ $# -eq 1 ]; then
    eval "echo $1: \${$1:-}"
  else
    shifu_trace_name="$1"; shift
    eval "echo $shifu_trace_name: $@"
  fi
}
