#! /bin/sh

# config
shifu_allow_options_anywhere=false

# modes
shifu_mode_cmds_run=1
shifu_mode_args_run=2
shifu_mode_help_run=3
shifu_mode_help_subs=4
shifu_mode_cmds_comp=5
shifu_mode_args_comp=6

shifu_cmd_name() {
  [ $# -ne 1 ] && _shifu_error "Commands cannot contain spaces got: \"$@\""
  [ ${shifu_mode:-0} -ne $shifu_mode_args_run ] && shifu_cmd_name="$1"
}

shifu_cmd_help() {
  [ ${shifu_mode:-0} -ne $shifu_mode_args_run ] && shifu_cmd_help="$@"
}

shifu_cmd_long() {
  [ ${shifu_mode:-0} -ne $shifu_mode_args_run ] && shifu_cmd_long="$@"
}

shifu_cmd_subs() {
  [ ${shifu_mode:-0} -ne $shifu_mode_args_run ] && shifu_cmd_subs="$@"
}

shifu_cmd_func() {
  [ ${shifu_mode:-0} -ne $shifu_mode_args_run ] && shifu_cmd_func="$@"
}

shifu_cmd_arg() {
  case ${shifu_mode:-0} in
    $shifu_mode_help_run)
      _shifu_arg_help "$@" ;;
    $shifu_mode_args_run)
      [ -n "${shifu_cmd_func:-}" ] && _shifu_update_case_stmt "$@" || _shifu_handle_arg_global "$@" ;;
    $shifu_mode_args_comp)
      _shifu_update_comp_case_stmt "$@" ;;
  esac
}

shifu_cmd_arg_comp_enum() {
  [ ${shifu_mode:-0} -ne $shifu_mode_args_comp ] && return
  [ "$shifu_arg_completion_set" = true ] && _shifu_error "Can only add one completion per argument"
  _shifu_append_on_new_line shifu_case_stmt '    [ \$# -ne 0 ] && shift'
  shifu_case_stmt="$shifu_case_stmt || { shifu_add_completions $@; break; }"
  [ ${shifu_parse_stage:-0} -ne 0 ] && shifu_tmp=";" || shifu_tmp=" ;;"
  shifu_case_stmt="$shifu_case_stmt$shifu_tmp"
  shifu_arg_completion_set=true
}

shifu_cmd_arg_comp_func() {
  [ ${shifu_mode:-0} -ne $shifu_mode_args_comp ] && return
  [ "$shifu_arg_completion_set" = true ] && _shifu_error "Can only add one completion per argument"
  _shifu_append_on_new_line shifu_case_stmt '    [ \$# -ne 0 ] && shift'
  shifu_case_stmt="$shifu_case_stmt || { $1; break; }"
  [ ${shifu_parse_stage:-0} -eq 0 ] && shifu_tmp=" ;;" || shifu_tmp=";"
  shifu_case_stmt="$shifu_case_stmt$shifu_tmp"
  shifu_arg_completion_set=true
}

shifu_cmd_arg_loc() {
  case $shifu_mode in
    $shifu_mode_help_run) _shifu_arg_help "$@" ;;
    $shifu_mode_args_run) _shifu_update_case_stmt "$@" ;;
    $shifu_mode_args_comp) _shifu_update_comp_case_stmt "$@" ;;
  esac
}

shifu_add_completions() {
  for completion in "$@"; do
    _shifu_add_completion "$completion"
  done
}

shifu_less() {
  cmd_name()          { shifu_cmd_name "$@"; }
  cmd_help()          { shifu_cmd_help "$@"; }
  cmd_long()          { shifu_cmd_long "$@"; }
  cmd_subs()          { shifu_cmd_subs "$@"; }
  cmd_func()          { shifu_cmd_func "$@"; }
  cmd_arg()           { shifu_cmd_arg "$@"; }
  cmd_arg_comp_enum() { shifu_cmd_arg_comp_enum "$@"; }
  cmd_arg_comp_func() { shifu_cmd_arg_comp_func "$@"; }
  cmd_arg_loc()       { shifu_cmd_arg_loc "$@"; }
  add_completions()   { shifu_add_completions "$@"; }
}

shifu_run() {
  # TODO: add tests for 0 & 1 cases
  case $# in
    0) echo "shifu_run requires at least one argument, got 0"
       exit 1 ;;
    1) _shifu_run "$@" ;;
    *) case "$2" in
        --tab-completion) _shifu_generate_tab_completion "$@" ;;
        --shifu-complete) _shifu_complete "$@" ;;
        *) _shifu_run "$@" ;;
       esac ;;
  esac
}

_shifu_run() {
  [ "${SHIFU_SET_X:-0}" = 1 ] && set -x
  shifu_mode=$shifu_mode_cmds_run
  shifu_parent="$1"; shifu_cmd="$1"; shift
  shifu_required_variables=""
  "$shifu_parent"
  _shifu_set_for_looping shifu_cmds shifu_cmd_subs
  while [ $# -ne 0 -a -n "${shifu_cmd_subs:-}" ]; do
    _shifu_parse_args true "$shifu_parent" "$@"
    shifu_mode=$shifu_mode_cmds_run
    shift $_shifu_args_parsed
    shifu_arg_matched=''
    for shifu_cmd in $shifu_cmds; do
      _shifu_clear_cmd_vars
      "$shifu_cmd"
      [ "$1" != "$shifu_cmd_name" ] && continue
      shifu_arg_matched=true; shift
      [ -n "$shifu_cmd_func" ] && break
      shifu_parent="$shifu_cmd"
      _shifu_set_for_looping shifu_cmds shifu_cmd_subs
      break
    done
    [ "$shifu_arg_matched" = true -a -n "$shifu_cmd_func" ] && break
    [ "$shifu_arg_matched" = true -a -n "$shifu_cmd_subs" ] && continue
    [ "$1" != "-h" -a "$1" != "--help" ] && echo "Unknown command: $1"
    _shifu_help "$shifu_parent" 1
  done
  [ -z "$shifu_cmd_func" ] && { echo "$shifu_cmd_name requires arguments"; _shifu_help "$shifu_cmd" 1; }
  case "${1:-}" in -h|--help) _shifu_help "$shifu_cmd" 0; esac
  _shifu_parse_args false "$shifu_cmd" "$@"
  [ $? -ne 0 ] && _shifu_help "$shifu_cmd" 1
  shift $_shifu_args_parsed
  [ "${SHIFU_SET_X:-0}" = 1 ] && set +x
  "$shifu_cmd_func" "$@"
}

_shifu_parse_args() {
  shifu_mode=$shifu_mode_args_run
  shifu_parse_stage=0
  shifu_parse_local="$1"; shifu_cmd="$2"; shift 2
  [ "$shifu_parse_local" = true ] && shifu_required_variables_local=""
  shifu_case_stmt="case \"\$1\" in"
  if [ "$shifu_parse_local" = false -a -n "${shifu_global_case:-}" ]; then
    _shifu_append_on_new_line shifu_case_stmt "  ${shifu_global_case:-}"
  fi
  _shifu_append_on_new_line shifu_case_stmt "  -h|--help) _shifu_help \"$shifu_cmd\" 0 ;; "
  "$shifu_cmd"
  [ $shifu_parse_stage -eq 0 ] && _shifu_update_case_stmt_invalid_option
  _shifu_append_on_new_line shifu_case_stmt "    break;;"
  _shifu_append_on_new_line shifu_case_stmt "esac"
  _shifu_args_parsed=0
  while [ $# -ne 0 ]; do
    eval "$shifu_case_stmt"
  done
  if [ "$shifu_parse_local" = true ]; then
    _shifu_set_for_looping shifu_required_vars shifu_required_variables_local
  else
    _shifu_set_for_looping shifu_required_vars shifu_required_variables
  fi
  for shifu_required_var in $shifu_required_vars; do
    eval "if [ \"\${$shifu_required_var+set}\" != set ]; then
      echo \"Required variable, $shifu_required_var, is not set\"
      exit 1
    fi"
  done
  [ "$shifu_parse_local" = true -o $# -eq 0 -o "$shifu_allow_options_anywhere" != false ] && return
  _shifu_error_if_options "$@"
}

_shifu_update_case_stmt() {
  shifu_no_options=true
  if [ "$1" != -- ]; then
    shifu_no_options=false
    _shifu_append_on_new_line shifu_case_stmt "  $1"
    shift
  fi
  while [ $# -gt 1 -a "$1" != -- ]; do
    shifu_case_stmt="${shifu_case_stmt}|$1"; shift
  done; shift
  # remaining
  if [ $# -eq 1 ]; then
    [ "$shifu_parse_local" = true ] && _shifu_error "Remaining arguments cannot be local: $1"
    [ $shifu_parse_stage -gt 1 ] && _shifu_error "Can only declare remaining arguments once: $1"
    [ $shifu_parse_stage -eq 0 ] && _shifu_update_case_stmt_invalid_option
    shifu_parse_stage=2
  # positional
  elif [ "$shifu_no_options" = true ]; then
    [ "$shifu_parse_local" = true ] && _shifu_error "Positional arguments cannot be local: $1"
    if [ $shifu_parse_stage -eq 0 ]; then
      shifu_parse_stage=1
      _shifu_update_case_stmt_invalid_option
    elif [ $shifu_parse_stage -gt 1 ]; then
      _shifu_error "No arguments after remaining are declared: $1"
    fi
    _shifu_set_variable "$1" ""
    _shifu_update_case_stmt_positional_check "$1"
    _shifu_append_on_new_line shifu_case_stmt "    $1=\\\$1; shift; _shifu_ack_arg"
  # option + argument, required
  elif [ $# -eq 2 ]; then
    _shifu_error_if_invalid_arg_order "$1" $shifu_parse_stage
    if [ "$shifu_parse_local" = true ]; then
      shifu_required_variables_local="${shifu_required_variables_local} $1"
    else
      shifu_required_variables="${shifu_required_variables} $1"
    fi
    shifu_case_stmt="$shifu_case_stmt) [ \$# -lt 2 ] && { echo \"Option \$1 requires a value\"; _shifu_help \"\$shifu_cmd\" 1; }; $1=\$2; shift 2; _shifu_ack_arg 2 ;;"
  # option + argument, with default
  elif [ $# -eq 3 ]; then
    _shifu_error_if_invalid_arg_order "$1" $shifu_parse_stage
    _shifu_set_variable "$1" "$2"
    shifu_case_stmt="$shifu_case_stmt) [ \$# -lt 2 ] && { echo \"Option \$1 requires a value\"; _shifu_help \"\$shifu_cmd\" 1; }; $1=\$2; shift 2; _shifu_ack_arg 2 ;;"
  # option no argument, binary: default/set
  elif [ $# -eq 4 ]; then
    _shifu_error_if_invalid_arg_order "$1" $shifu_parse_stage
    _shifu_set_variable "$1" "$2"
    shifu_case_stmt="$shifu_case_stmt) $1=$3; shift; _shifu_ack_arg ;;"
  fi
}

_shifu_handle_arg_global() {
  shifu_no_options=true
  if [ "$1" != -- ]; then
    shifu_no_options=false
    shifu_global_case="${shifu_global_case:-}$1"
    shifu_global_help="${shifu_global_help:-}\n  $1"
    shift
  fi
  while [ $# -gt 1 -a "$1" != -- ]; do
    shifu_global_case="${shifu_global_case:-}|$1"
    shifu_global_help="${shifu_global_help:-}, $1"
    shift
  done; shift
  # remaining
  if [ $# -eq 1 ]; then
    _shifu_error "Remaining arguments cannot be global"
  # positional
  elif [ "$shifu_no_options" = true ]; then
    _shifu_error "Positional arguments cannot be global: $1"
  # option + argument, required
  elif [ $# -eq 2 ]; then
    shifu_required_variables="${shifu_required_variables} $1"
    shifu_global_case="${shifu_global_case:-}) [ \\\$# -lt 2 ] && { echo \\\"Option \\\$1 requires a value\\\"; _shifu_help \\\"\\\$shifu_cmd\\\" 1; }; $1=\\\$2; shift 2; _shifu_ack_arg 2 ;;"
    shifu_global_help="${shifu_global_help:-} [$1]\n    $2\n    Required"
  # option + argument, with default
  elif [ $# -eq 3 ]; then
    _shifu_set_variable "$1" "$2"
    shifu_global_case="${shifu_global_case:-}) [ \\\$# -lt 2 ] && { echo \\\"Option \\\$1 requires a value\\\"; _shifu_help \\\"\\\$shifu_cmd\\\" 1; }; $1=\\\$2; shift 2; _shifu_ack_arg 2 ;;"
    shifu_global_help="${shifu_global_help:-} [$1]\n    $3\n    Default: $2"
  # option no argument, binary: default/set
  elif [ $# -eq 4 ]; then
    _shifu_set_variable "$1" "$2"
    shifu_global_case="${shifu_global_case:-}) $1=$3; shift; _shifu_ack_arg ;;"
    shifu_global_help="${shifu_global_help:-}\n    $4\n    Default: $2, set: $3"
  fi
}

_shifu_ack_arg() {
  _shifu_args_parsed=$((_shifu_args_parsed + ${1:-1}))
}

_shifu_clear_cmd_vars() {
    shifu_cmd_name='' shifu_cmd_help='' shifu_cmd_long='' shifu_cmd_subs='' shifu_cmd_func=''
}

_shifu_help() {
  shifu_mode=$shifu_mode_cmds_run
  "$1"
  _shifu_make_subcmd_help
  shifu_mode=$shifu_mode_help_run
  _shifu_clear_cmd_vars
  shifu_help_stage=0
  "$1"
  [ -n "$shifu_cmd_func" ] && shifu_help_options="${shifu_help_options:-}${shifu_global_help:-}"
  shifu_help_options="${shifu_help_options:-}\n  -h, --help\n    Show this help"
  [ -n "${shifu_help_usage:-}" ] && shifu_help_usage="$shifu_cmd_name [OPTIONS]$shifu_help_usage"
  [ -n "$shifu_cmd_help" ] && _shifu_add_to_help_string "$shifu_cmd_help"
  [ -n "$shifu_cmd_long" ] && _shifu_add_to_help_string "$shifu_cmd_long"
  [ -n "${shifu_help_usage:-}" ] && _shifu_add_to_help_string "Usage\n  $shifu_help_usage"
  [ -n "${shifu_help_arguments:-}" ] && _shifu_add_to_help_string "Arguments$shifu_help_arguments"
  [ -n "${shifu_subcmd_help:-}" ] && _shifu_add_to_help_string "Subcommands$shifu_subcmd_help"
  [ -n "$shifu_help_options" ] && _shifu_add_to_help_string "Options$shifu_help_options"
  [ -n "$shifu_help_string" ] && printf "$shifu_help_string\n"
  exit $2
}

_shifu_add_to_help_string() {
  [ -z "${shifu_help_string:-}" ] && shifu_help_string="$1" || shifu_help_string="$shifu_help_string\n\n$1"
}

_shifu_make_subcmd_help() {
  shifu_mode=$shifu_mode_help_subs
  [ -z "${shifu_cmd_subs:-}" ] && return
  _shifu_set_for_looping shifu_subcmds shifu_cmd_subs
  _shifu_clear_cmd_vars
  for shifu_subcmd in $shifu_subcmds; do
    shifu_help_stage=0
    "$shifu_subcmd"
    shifu_subcmd_help="${shifu_subcmd_help:-}\n  $shifu_cmd_name"
    [ -n "${shifu_cmd_help:-}" ] && shifu_subcmd_help="${shifu_subcmd_help:-}\n    $shifu_cmd_help"
  done
}

_shifu_arg_help() {
  shifu_no_options=true
  if [ "$1" != -- ]; then
    shifu_no_options=false
    shifu_help_options="${shifu_help_options:-}\n  $1"
    shift
  fi
  while [ $# -gt 1 -a "$1" != -- ]; do
    shifu_help_options="$shifu_help_options, $1"; shift
  done; shift
  # remaining
  if [ $# -eq 1 ]; then
    shifu_help_stage=2
    shifu_help_usage="$shifu_help_usage ...[REMAINING]"
    shifu_help_arguments="$shifu_help_arguments\n  REMAINING\n    $1"
  # positional
  elif [ "$shifu_no_options" = true ]; then
    if [ $shifu_help_stage -lt 1 ]; then
      shifu_help_stage=1
    elif [ $shifu_help_stage -gt 1 ]; then
      _shifu_error "No arguments after remaining are declared: $1"
    fi
    shifu_help_usage="${shifu_help_usage:-} [$1]"
    shifu_help_arguments="${shifu_help_arguments:-}\n  $1\n    $2"
  # option + argument, required
  elif [ $# -eq 2 ]; then
    _shifu_error_if_invalid_arg_order "$1" $shifu_help_stage
    shifu_help_options="$shifu_help_options [$1]\n    $2\n    Required"
  # option + argument, with default
  elif [ $# -eq 3 ]; then
    _shifu_error_if_invalid_arg_order "$1" $shifu_help_stage
    shifu_help_options="$shifu_help_options [$1]\n    $3\n    Default: $2"
  # option no argument, binary: default/set
  elif [ $# -eq 4 ]; then
    _shifu_error_if_invalid_arg_order "$1" $shifu_help_stage
    shifu_help_options="$shifu_help_options\n    $4\n    Default: ${2:-empty}, set: $3"
  fi
}

_shifu_generate_tab_completion() {
  shifu_mode=$shifu_mode_cmds_run
  "$1"
  case "$3" in
    zsh) _shifu_generate_zsh_tab_completion "$@";;
    bash) _shifu_generate_bash_tab_completion "$@";;
    help) _shifu_tab_completion_help ;;
    *) echo "Unknown shell, $3, cannot perform tab completion"; exit 1 ;;
  esac
}

_shifu_tab_completion_help() {
  echo "Generate tab completion code for specified shell

Instructions
1. Ensure $shifu_cmd_name is in a directory on your shell's PATH
2. Ensure $shifu_cmd_name has access to shifu; either by putting
   shifu in the same PATH directory as $shifu_cmd_name or adding
   shifu to another PATH directory
3. If you're using zsh, ensure that you've loaded and run
   compinit before the following eval call in your zshrc file
4. Add the following to your shell's rc file
     eval \"\$($shifu_cmd_name --tab-completion <shell>)\"
   replacing <shell> with your shell. Supported shells:
     zsh, bash"
}

_shifu_generate_zsh_tab_completion() {
  echo "_${shifu_cmd_name}_completion() {
  current=\"\${words[\$CURRENT]}\"
  full_words=( \"\${words[@]:1:\${#words[@]}-2}\" )
  compadd -q -- \$($shifu_cmd_name --shifu-complete \"\$current\" \"\${full_words[@]}\")
}
compdef _${shifu_cmd_name}_completion $shifu_cmd_name"
}

_shifu_generate_bash_tab_completion() {
  echo "_${shifu_cmd_name}_completion() {
  current=\"\${COMP_WORDS[\${#COMP_WORDS[@]}-1]}\"
  full_words=( \"\${COMP_WORDS[@]:1:\${#COMP_WORDS[@]}-2}\" )
  completions=\$($shifu_cmd_name --shifu-complete \"\$current\" \"\${full_words[@]}\")
  COMPREPLY=( \$(compgen -W \"\$completions\" -- \"\$current\") )
}
complete -F _${shifu_cmd_name}_completion $shifu_cmd_name"
}

_shifu_complete() {
  shifu_mode=$shifu_mode_cmds_comp
  shifu_parent="$1"; shifu_cmd="$1"; shifu_current_word="$3"; shift 3
  # current word is only non-empty if there are ascii chars after the last full word
  "$shifu_parent"
  _shifu_set_for_looping shifu_cmds shifu_cmd_subs
  while [ $# -ne 0 -a -n "${shifu_cmd_subs:-}" ]; do
    _shifu_complete_func_args true "$shifu_parent" "$@"
    shifu_comp_global_option_names="${shifu_comp_option_names:-}"
    shifu_mode=$shifu_mode_cmds_comp
    shifu_arg_matched=''
    for shifu_cmd in $shifu_cmds; do
      _shifu_clear_cmd_vars
      "$shifu_cmd"
      [ "$1" != "$shifu_cmd_name" ] && continue
      shifu_arg_matched=true; shift
      [ -n "$shifu_cmd_func" ] && break
      shifu_parent="$shifu_cmd"
      _shifu_set_for_looping shifu_cmds shifu_cmd_subs
      break
    done
    [ "$shifu_arg_matched" = true -a -n "$shifu_cmd_subs" ] && continue
    break
  done
  shifu_comp_option_names="${shifu_comp_global_option_names:-}"
  [ -n "${shifu_cmd_func:-}" ] && _shifu_complete_func_args false "$shifu_cmd" "$@"
  [ -n "${shifu_cmd_subs:-}" -a $# -eq 0 ] && _shifu_complete_subcmd_names
  [ -n "${shifu_completions:-}" ] && echo "$shifu_completions"
}

_shifu_complete_subcmd_names() {
  "$shifu_parent"
  _shifu_set_for_looping shifu_cmds shifu_cmd_subs
  for shifu_cmd in $shifu_cmds; do
    "$shifu_cmd"
    _shifu_add_completion "$shifu_cmd_name"
  done
}

_shifu_complete_func_args() {
  shifu_mode=$shifu_mode_args_comp
  shifu_parse_stage=0
  shifu_parse_local="$1"; shifu_cmd="$2"; shift 2
  shifu_case_stmt="case \"\${1:-}\" in "
  shifu_arg_completion_set=true
  "$shifu_cmd"
  case "${shifu_current_word:-}" in
    -*|--*)
      _shifu_set_for_looping shifu_comp_option_list shifu_comp_option_names
      _shifu_filter_matching_options "$shifu_current_word" $shifu_comp_option_list
      return 0 ;;
  esac
  if [ $shifu_parse_stage -eq 0 -a $shifu_arg_completion_set = false ]; then
    shifu_case_stmt="$shifu_case_stmt shift ;;"
  fi
  if [ "$shifu_parse_local" = true ]; then
    _shifu_append_on_new_line shifu_case_stmt "  *) break ;;"
  else
    _shifu_append_on_new_line shifu_case_stmt "    break ;;"
  fi
  _shifu_append_on_new_line shifu_case_stmt "esac"
  while true; do
    eval "$shifu_case_stmt"
  done
}

_shifu_update_comp_case_stmt() {
  if [ "$shifu_arg_completion_set" = false -a $shifu_parse_stage -eq 0 ]; then
    shifu_case_stmt="$shifu_case_stmt shift ;;"
  fi
  shifu_arg_completion_set=false
  shifu_no_options=true
  if [ "$1" != -- ]; then
    shifu_no_options=false
    _shifu_append_on_new_line shifu_case_stmt "  $1"
    shifu_comp_option_names="${shifu_comp_option_names:-}${shifu_comp_option_names:+ }$1"
    shift
  fi
  while [ $# -gt 1 -a "$1" != -- ]; do
    shifu_case_stmt="${shifu_case_stmt}|$1"
    shifu_comp_option_names="$shifu_comp_option_names $1"
    shift
  done; shift
  # remaining
  if [ $# -eq 1 ]; then
    [ "$shifu_parse_local" = true ] && _shifu_error "Remaining arguments cannot be local: $1"
    [ $shifu_parse_stage -eq 2 ] && _shifu_error "Can only declare remaining arguments once: $1"
    shifu_parse_stage=2
  # positional
  elif [ "$shifu_no_options" = true ]; then
    [ "$shifu_parse_local" = true ] && _shifu_error "Positional arguments cannot be local: $1"
    if [ $shifu_parse_stage -eq 0 ]; then
      shifu_parse_stage=1
      _shifu_append_on_new_line shifu_case_stmt "  *)"
    elif [ $shifu_parse_stage -gt 1 ]; then
      _shifu_error "No arguments after remaining are declared: $1"
    fi
  # option + argument, required
  elif [ $# -eq 2 ]; then
    _shifu_error_if_invalid_arg_order "$1" $shifu_parse_stage
    shifu_case_stmt="$shifu_case_stmt) shift;"
  # option + argument with default
  elif [ $# -eq 3 ]; then
    _shifu_error_if_invalid_arg_order "$1" $shifu_parse_stage
    shifu_case_stmt="$shifu_case_stmt) shift;"
  # option no argument, binary default/set
  elif [ $# -eq 4 ]; then
    _shifu_error_if_invalid_arg_order "$1" $shifu_parse_stage
    # has no value that could be completed
    shifu_case_stmt="$shifu_case_stmt)"
  fi
}

_shifu_add_completion() {
    if [ -z "${shifu_completions:-}" ]; then
      shifu_completions="$1"
    else
      shifu_completions="$shifu_completions $1"
    fi
}

_shifu_filter_matching_options() {
  shifu_filter_current_word="$1"; shift
  for shifu_filter_option in "$@"; do
    case "$shifu_filter_option" in
      "$shifu_filter_current_word"*)
        _shifu_add_completion "$shifu_filter_option" ;;
    esac
  done
}

_shifu_update_case_stmt_invalid_option() {
  shifu_case_stmt="$shifu_case_stmt
  -*|--*) echo \"Invalid option: \$1\"; _shifu_help \"\$shifu_cmd\" 1 ;;
  *)"
}

_shifu_append_on_new_line() {
  eval "$1=\"\$$1
$2\""
}

_shifu_error_if_options() {
  while [ $# -gt 0 ]; do
    case "$1" in
      -*|--*) echo "No options allowed after any positional argument: $1"; return 1 ;;
    esac
    shift
  done
}

_shifu_update_case_stmt_positional_check() {
    positional_clause="[ \$# -eq 0 ] && {"
    if [ "$shifu_allow_options_anywhere" = false ]; then
      _shifu_append_on_new_line positional_clause "      _shifu_error_if_options \"\$1\" && return 1"
    fi
    _shifu_append_on_new_line positional_clause "      echo 'Missing positional argument $1'"
    _shifu_append_on_new_line positional_clause "      _shifu_help \"\$shifu_cmd\" 1
    }"
    _shifu_append_on_new_line shifu_case_stmt "    $positional_clause"
}

_shifu_set_for_looping() {
  eval "[ -z \"\${$2:-}\" ] && { $1=''; return; }"
  if [ -n "${ZSH_VERSION:-}" ]; then
    eval "$1=( \${=$2} )"
  else
    eval "$1=\$$2"
  fi
}

_shifu_set_variable() {
  eval "$1=\"$2\"" > /dev/null 2>&1
  [ $? -eq 0 ] && return 0
  _shifu_error "Invalid variable name: $1"
}

_shifu_error_if_invalid_arg_order() {
  [ $2 -eq 0 ] && return
  _shifu_error "No options after positional/remaining arguments: $1"
}

_shifu_error() {
  echo "$1"
  exit 1
}

_shifu_trace() {
  if [ $# -eq 1 ]; then
    eval "echo $1: \${$1:-}"
  else
    shifu_trace_name="$1"; shift
    eval "echo $shifu_trace_name: $@"
  fi
}

if [ $# -gt 0 -a "$1" = less ]; then shifu_less; fi
