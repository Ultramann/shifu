# Dependencies: tr, wc

# Future options?
shifu_command_function_pattern='^(.*) ?\(\) {'

shifu_mode_init="shifu_mode_init"
shifu_mode_parse="shifu_mode_parse"
shifu_mode_help="shifu_mode_help"

# for c in {0..15}; do tput setaf $c; tput setaf $c | echo $c: text; done
shifu_grey="$(tput setaf 0)"
shifu_red="$(tput setaf 1)"
shifu_green="$(tput setaf 2)"
shifu_reset="$(tput sgr0)"

shifu_log_flag='--shifu-log'

# Write input arguments to stdout starting with green "shifu"
shifu_log() {
  [ "$shifu_logging" = true ] && echo "${shifu_green}shifu${shifu_reset}  $@"
}

# Write input to stderr
shifu_stderr() {
  echo "$@" >&2
}

# Write input arguments to stderr starting with red "debug"
shifu_debug() {
  shifu_stderr "${shifu_red}debug${shifu_reset}  $@"
}

shifu_var_store() {
  while [ $# -ne 0 ]; do
    eval "${1}_old=\$$1"
    shift
  done
}

shifu_var_restore() {
  while [ $# -ne 0 ]; do
    eval "$1=\$${1}_old; unset -v ${1}_old"
    shift
  done
}

shifu_count_char() {
  printf $(tr -cd "$1" | wc -c)
}

# Convert spaces to newlines to enable looping
shifu_iterate() {
  printf "$1\n" | tr ' ' '\n'
}

# Convert newlines to spaces
shifu_collapse() {
  printf "$1" | tr '\n' ' '
}

# Write newline separated "array" as "( arg1 arg2 ... argn )" to stdout
shifu_array_fmt() {
  printf "( $(shifu_collapse "$1") )"
}

# Write number of elements in newline separated "array" to stdout
shifu_array_length() {
  shifu_iterate "$1" | wc -l
}

# Write newline separated "array" with element added at end to stdout
shifu_array_append() {
  # 1: array, 2: element
  [ "${#1}" -gt 0 ] && { echo "$1"; echo "$2"; } || echo "$2"
}

# Test if newline separated array contains first argument,
# write true to stdout if found, else false. Examples
# [argument other arg] arg -> true
# [argument other arg] no -> false
shifu_array_contains() {
  # 1: array, 2: value
  shifu_var_store element result
  result=false
  for element in $(shifu_iterate "$1"); do
    [ "$element" = "$2" ] && { result=true; break; }
  done
  echo $result
  shifu_var_restore element result
}

# Filter newline separated "array" by words containing first argment as prefix,
# write matching elements to stdout. Examples
#   [argument other arg3] arg -> "argument arg3"
#   [argument other arg3] oth -> "other"
shifu_array_filter_prefix() {
  # 1: array, 2: prefix
  [ -z "$2" ] && { echo "$1"; return; }
  shifu_var_store element
  for element in $(shifu_iterate "$1"); do
    [ "${element#"$2"}" != "$element" ] && echo "$element"
  done
  shifu_var_restore element
}

# Write the absolute path of the calling script, $0, to stdout
shifu_caller_script() {
  echo $(realpath $(basename $0))
}

# Reads function names in passed script path matching the regex pattern
# shifu_command_function_pattern to global variable `script_functions`
shifu_read_script_functions() {
  # 1: script path
  script_functions=$(
    cat "$1" | \
    # -r: extended regex, -n: don't echo lines to stdout
    sed -rn "/$shifu_command_function_pattern/!d;
            s/$shifu_command_function_pattern/\1/p"
  )
}

# This must be passed actual positional arguments
shifu_determine_function_to_call() {
  shifu_var_store uscore_candidate spaced_candidate filtered_functions
  uscore_candidate=""
  spaced_candidate=""
  filtered_functions="$script_functions"

  shifu_var_store argument tmp_functions
  for argument in "$@"; do
    tmp_functions=$(shifu_array_filter_prefix "$filtered_functions" "$uscore_candidate")
    [ $(shifu_array_length "$tmp_functions") -le 1 ] && break
    uscore_candidate="${uscore_candidate}${argument}_"
    spaced_candidate="${spaced_candidate}${argument} "
    filtered_functions="$tmp_functions"
  done
  shifu_var_restore argument tmp_functions

  shifu_var_store candidate_function found_function
  candidate_function="${uscore_candidate%_}"
  found_function=$(shifu_array_contains "$script_functions" "$candidate_function")

  shifu_log filtered functions: $(shifu_array_fmt "$filtered_functions")
  shifu_log candidate function: "$candidate_function"

  shifu_var_restore uscore_candidate filtered_functions

  if [ "$found_function" = true ]; then
    function_to_call="$candidate_function"
    arguments_in_function="${spaced_candidate% }"
    shifu_log function to call: "$function_to_call"
    shifu_var_restore candidate_function found_function
    return 0
  # todo: have branch for when function found and arg is --help
  else
    shifu_stderr "${spaced_candidate% * } has no subcommand ${candidate_function##*_}"
    # shifu_help "${spaced_candidate% * }"
    shifu_var_restore candidate_function found_function spaced_candidate
    return 1
  fi
}

shifu_function_to_call_argument_length() {
  echo "$arguments_in_function" | tr -sc " " "*" | tr -d " " | wc -m
}

shifu_run() {
  [ "$1" = "$shifu_log_flag" ] && { shifu_logging=true; shift; }

  shifu_var_store script_functions function_to_call arguments_in_function

  shifu_read_script_functions $(shifu_caller_script)
  shifu_determine_function_to_call "$@"; status=$?
  [ $status != 0 ] && return $status
  # shift input arguments function length to leave intended arguments
  for i in $(seq 1 $(shifu_function_to_call_argument_length)); do shift; done;
  $function_to_call "$@"

  shifu_var_restore script_functions function_to_call arguments_in_function
}

shifu_invalid_variable_name() {
  [ -n $(eval "$1= && echo valid") ] && return 1 || return 0
}

shifu_arg_ob() {
  # 1: option, 2: variable name, 3: set value, 4: help
  case "$shifu_mode" in
    "$shifu_mode_init")
      if shifu_invalid_variable_name "$2"; then
        echo "Invalid variable name: $1"
        return 1
      fi
      case "$3" in
        true) eval "$2=false" ;;
        false) eval "$2=true" ;;
        *) echo "Set value expected to be boolean, got: $3"; exit 1 ;;
      esac
      ;;
    "$shifu_mode_parse")
      [ "$shifu_one" = "--$1" ] && { eval "$2=$3"; shifu_parsed=1; }
      ;;
    "$shifu_mode_help") echo "$4"
      ;;
  esac
}

shifu_parse_args() {
  # 1: function, 2-: args to parse
  shifu_var_store shifu_func shifu_mode shifu_one shifu_two shifu_parsed
  shifu_func="$1"; shift

  shifu_mode="$shifu_mode_init"
  $shifu_func "$@"

  shifu_mode="$shifu_mode_parse"
  while true; do
    shifu_one="$1"
    shifu_two="$2"
    shifu_parsed=0
    $shifu_func "$@"
    [ $shifu_parsed -eq 0 ] && break
    for i in $(seq 1 $shifu_parsed); do shift; done
  done
  shifu_positional_args="$@"
  shifu_var_restore shifu_func shifu_mode shifu_one shifu_two shifu_parsed
}
